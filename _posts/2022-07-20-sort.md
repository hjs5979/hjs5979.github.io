---
layout: single
title: 선택정렬, 삽입정렬, 퀵정렬
categories: 알고리즘
tag: [Algorithm]
use_math: true
toc: true
author_profile: true
sidebar:
  nav: docs
---

정렬 알고리즘에 대해서 정리해봤습니다.

# 선택 정렬

선택 정렬은 가장 원시적인 방법으로, 모든 데이터에서 가장 작은 데이터를 찾아 맨 앞의 데이터와 변경하고, 앞으로 간 데이터를 제외한 모든 데이터들 중에 다시 가장 작은 데이터를 찾아 앞에서 두번째 데이터와 변경하는 과정을 반복합니다. 실제로는 배열을 순회하면서 데이터가 작은 값과 계속해서 순서를 바꾸는 방식으로 진행됩니다.
예시를 통해 설명해보도록 하겠습니다.

**ex)**

- 초기상태 7 5 9 0 3

- 1회전 : (5) (7) 9 0 3 ➡ (5) 7 (9) 0 3 ➡ (0) 7 9 (5) 3 ➡ (0) 7 9 5 (3)

1회전 설명 : 가장 작은 데이터를 찾는 과정입니다. 5와 7 교환 ➡ 5와 9 교환 x ➡ 0과 5을 교환 ➡ 0과 3 교환 x

- 2회전 : 0 (7) (9) 5 3 ➡ 0 (5) 9 (7) 3 ➡ 0 (3) 9 7 (5)

2회전 설명 : 두번째로 작은 데이터를 찾는 과정입니다. 7과 9 교환 x ➡ 5와 7 교환 x ➡ 3과 5 교환

이 과정을 반복합니다.

선택 정렬의 연산횟수는 N + (N-1) + (N-2) + $\cdots$ + 2 입니다. 이는 $(N^2 + N) / 2 - 1$ 이고 빅오 표기법을 통해 표현하면 시간복잡도는 $O(N^2)$입니다. 비효율적인 방법이지만 특정 리스트에서 가장 작은 데이터를 찾는 일이 많으므로 이해하고 있는 것이 필요합니다.

<br>

# 삽입 정렬

삽입 정렬은 맨 앞에 있는 데이터는 정렬되어 있다고 가정하고 그 다음 데이터부터 정렬하게 됩니다. 비교 대상의 데이터가 작을 때, 해당 위치에 자신을 삽입합니다. 이를 반복하여 정렬되는 방식입니다.
예시를 통해 설명해보도록 하겠습니다.

ex)

- 초기상태 : 7 5 9 0 3

➡ 두번째 데이터인 5와 첫번째 데이터인 7을 비교했을 때, 5가 작기 때문에 7 위치에 5를 삽입합니다.

- 1회전 결과 : (5) 7 9 0 3

➡ 세번째 데이터인 9와 두번째 데이터 비교합니다. 9가 더 크기 때문에 비교가 종료됩니다.

- 2회전 결과 : 5 7 (9) 0 3

➡ 네번째 데이터인 0과 세번째 데이터를 비교합니다. 0이 작기 때문에 비교가 계속 진행됩니다. 동일하게 두번째 데이터, 첫번째 데이터와 비교가 진행되고, 5의 위치에 0이 삽입됩니다.

- 3회전 결과: (0) 5 7 9 3

이 과정이 반복됩니다.

삽입 정렬의 시간복잡도 또한 선택정렬과 같은 $O(N^2)$이지만 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작하여 시간복잡도는 $O(N)$까지 줄게 됩니다. 이러한 특정한 상황에 사용하면 효율이 올라간다는 점이 삽입정렬의 큰 장점이라고 생각할 수 있습니다.

<br>

# 버블 정렬

버블 정렬은 인접한 두 데이터를 비교하여 그 크기에 따라 위치를 서로 교환하는 정렬 방식입니다.

- 초기상태 : 7 5 9 0 3

- 1회전 : (5) (7) 9 0 3 ➡ 5 (7) (9) 0 3 ➡ 5 7 (0) (9) 3 ➡ 5 7 0 (3) (9)

1회전 설명 : 7과 5를 비교하여 위치 교환 ➡ 7과 9를 비교, 위치 교환 x ➡ 9과 0를 비교하여 위치 교환 ➡ 9와 3를 비교하여 위치 교환

- 2회전 : (5) (7) 0 3 9 ➡ 5 (0) (7) 3 9 ➡ 5 0 (3) (7) 9

2회전 설명 : 7과 5를 비교, 위치 교환 x ➡ 7과 0을 비교하여 위치 교환 ➡ 7과 3을 비교하여 위치 교환

이 과정을 반복합니다.

평균과 최악의 모두 수행 시간 복잡도는 $O(N^2)$입니다.

<br>

# 퀵 정렬

퀵 정렬은 맨 앞의 데이터를 기준으로 삼고 데이터를 기준 데이터보다 작은 데이터와 기준데이터보다 큰 데이터로 나눈 후, 작은 데이터와 큰 데이터 각자 정렬시키는 방식입니다.
예시를 통해 설명해보도록 하겠습니다.

(5) 7 9 0 3 1 6 2 4 8 ➡ 5를 기준으로 데이터 분리

좌측탐색 : 7부터 시작하는 탐색단계에서는 5보다 큰 숫자를 찾고

우측탐색 : 8부터 시작하는 탐색단계에서는 5보다 작은 숫자를 찾는다.

좌측탐색에서는 7이 5보다 크기 때문에 선택되고 우측탐색에서는 4가 5보다 작기 때문에 선택된다. -> 둘의 위치가 변경된다.

(5) 4 9 0 3 1 6 2 7 8

위의 방식을 이어서하면 다음과 같이 정렬이 된다.

(5) 4 2 0 3 1 6 9 7 8

이 단계에서는 좌측과 우측에 5보다 크거나 작은 데이터가 없기 때문에 탐색 위치가 1과 6에서 서로 엉키게 된다. 때문에 여기서 탐색을 멈추고 1과 6에서 작은 수와 기준 데이터인 5와 변경한다.

1 4 2 0 3 / 5 / 6 9 7 8

이제 5보다 작은 데이터와 큰 데이터 각자 같은 방법을 반복하면 정렬이 완성됩니다.

퀵정렬의 평균 시간 복잡도는 $O(NlogN)$입니다. 앞의 두 정렬 알고리즘에 비해 굉장히 빠릅니다. 하지만 이미 데이터가 정렬되어있다면 시간복잡도는 $N(O^2)$이 된다는 단점이 있습니다.

<br>

# 계수 정렬

계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현될 수 있을 때만 사용할 수 있습니다. 예를 들어 시험성적의 경우에 0 ~ 100으로 제한되어 있고 정수형태이기 때문에 이러한 데이터에 적합하다고 설명할 수 있습니다. 계수정렬은 데이터 정수 범위만큼의 리스트를 만들어주고, 맨 앞부터 데이터를 세면서 데이터 값이 해당하는 리스트 위치의 값을 늘려주는 방법입니다.
예시를 통해 설명해보도록 하겠습니다.

ex)
7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

데이터의 최대값은 9입니다. 때문에 0~9 범위의 리스트를 생성해줍니다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

(7) 5 9 0 3 1 6 2 9 1 4 8 0 5 2

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | (1) | 0   | 0   |

7 (5) 9 0 3 1 6 2 9 1 4 8 0 5 2

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | (1) | 0   | 1   | 0   | 0   |

이를 반복하면 리스트가 완성되고, 등장한 가장 작은 수부터 차례로 출력하면 정렬이 완성됩니다.

계수정렬은 최악의 경우에도 $O(N+K)$를 보장합니다.(K는 데이터의 최대값) 하지만 K가 너무 클 경우와 최대값과 최소값의 차이가 클 경우에는 효율성이 떨어집니다. 이를 고려하여 방법을 선택하면 됩니다.

<br>

# 쉘 정렬

쉘 정렬은 입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식입니다.

평균 수행 시간 복잡도는 $O(N^1.5)$이고, 최악의 수행 시간 복잡도는 $O(N^2)$입니다.

<br>

# 힙 정렬

힙 정렬은 전이진 트리를 이용한 정렬 방식입니다. 구성된 전이진 트리를 힙 트리로 변환하여 정렬합니다.

평균과 최악 모두 시간 복잡도는 $O(nlog_2 5)$입니다.

<br>

# 2-Way 합병 정렬

2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬방식입니다.

평균과 최악 모두 시간 복잡도는 $O(nlog_2 n)$입니다.

<br>

# 기수 정렬

기수 정렬은 Queue를 이용하여 자릿수 별로 정렬하는 방식입니다. 같은 데이터는 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 데이터를 꺼내어 정렬하는 방식입니다.

평균과 최악 모두 시간 복잡도는 $O(dn)$입니다.

# 정리

<table style="border: 2px;">
  <th>
    <td> 컨텐츠 내용1 </td>
    <td> 컨텐츠 내용2 </td>
    <td> 컨텐츠 내용3 </td>
  </th>
  <tr>
    <td> 컨텐츠 내용1 </td>
    <td> 컨텐츠 내용2 </td>
    <td> 컨텐츠 내용3 </td>
  </tr><tr>
    <td colspan="3"> 컨텐츠 내용4 </td>
  </tr><tr>
    <td> 컨텐츠 내용5 </td>
    <td colspan="2"> 컨텐츠 내용6 </td>
  </tr><tr>
    <td rowspan="3"> 컨텐츠 내용7 </td>
  </tr><tr>
    <td> 컨텐츠 내용8-1 </td>
    <td> 컨텐츠 내용9-1 </td>
  </tr><tr>
    <td> 컨텐츠 내용8-2 </td>
    <td> 컨텐츠 내용9-2 </td>
  </tr>
</table>
