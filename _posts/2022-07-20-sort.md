---
layout: single
title:  선택정렬, 삽입정렬, 퀵정렬
categories: 검정
tag: [Statistic, Algorithm]
use_math: true
toc: true
author_profile: true
sidebar:
  nav: docs
---

정렬 알고리즘에 대해서 정리해봤습니다.

# 선택 정렬

선택정렬은 가장 원시적인 방법으로, 모든 데이터에서 가장 작은 데이터를 찾아 맨 앞의 데이터와 변경하고, 앞으로 간 데이터를 제외한 모든 데이터들 중에 다시 가장 작은 데이터를 찾아 앞에서 두번째 데이터와 변경하는 과정을 반복합니다.
예시를 통해 설명해보도록 하겠습니다.

ex) 

7 5 9 (0) 3 1 6 2 4 8 -> 괄호 친 0이 가장 작은 데이터 입니다.

0 5 9 7 3 1 6 2 4 8 -> 맨 앞의 7과 변경합니다.

0 5 9 7 3 (1) 6 2 4 8 -> 그 다음은 1이 제일 작습니다.

0 1 5 9 7 3 6 2 4 8 -> 5와 변경됩니다. 과정을 반복합니다.

선택정렬의 연산횟수는 N + (N-1) + (N-2) + $\cdots$ + 2 입니다. 이는 $(N^2 + N) / 2 - 1$ 이고 빅오 표기법을 통해 표현하면 시간복잡도는 $O(N^2)$입니다. 비효율적인 방법이지만 특정 리스트에서 가장 작은 데이터를 찾는 일이 많으므로 이해하고 있는 것이 필요합니다.

# 삽입 정렬

삽입정렬은 맨 앞에 있는 데이터는 정렬되어 있다고 가정하고 그 다음 데이터부터 정렬하게 됩니다. 데이터가 자신 이전 데이터보다 작은 경우 서로 위치를 변경하는 방식을 반복하여 정렬되는 방식입니다.
예시를 통해 설명해보도록 하겠습니다.

ex)

7 (5) 9 0 3 1 6 2 4 8 -> 두번째 데이터인 5 선택, 이전 데이터인 7과 비교

5 7 (9) 0 3 1 6 2 4 8 -> 위치 변경, 그 다음 데이터인 9 선택, 7과 비교

5 7 9 (0) 3 1 6 2 4 8 -> 위치변경없음, 0 선택

0 5 7 9 3 1 6 2 4 8 -> 0은 5,7,9보다 작으므로 맨 앞으로 이동됨 -> 이러한 과정 반복

삽입정렬의 시간복잡도 또한 선택정렬과 같은 $O(N^2)$이지만 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작하여 시간복잡도는 $O(N)$까지 줄게 됩니다. 이러한 특정한 상황에 사용하면 효율이 올라간다는 점이 삽입정렬의 큰 장점이라고 생각할 수 있습니다.

# 퀵 정렬

퀵정렬은 맨 앞의 데이터를 기준으로 삼고 데이터를 기준 데이터보다 작은 데이터와 기준데이터보다 큰 데이터로 나눈 후, 작은 데이터와 큰 데이터 각자 정렬시키는 방식입니다.
예시를 통해 설명해보도록 하겠습니다.

(5) 7 9 0 3 1 6 2 4 8 -> 5를 기준으로 데이터 분리

좌측탐색 : 7부터 시작하는 탐색단계에서는 5보다 큰 숫자를 찾고

우측탐색 : 8부터 시작하는 탐색단계에서는 5보다 작은 숫자를 찾는다.

좌측탐색에서는 7이 5보다 크기 때문에 선택되고 우측탐색에서는 4가 5보다 작기 때문에 선택된다. -> 둘의 위치가 변경된다.

(5) 4 9 0 3 1 6 2 7 8

위의 방식을 이어서하면 다음과 같이 정렬이 된다.

(5) 4 2 0 3 1 6 9 7 8

이 단계에서는 좌측과 우측에 5보다 크거나 작은 데이터가 없기 때문에 탐색 위치가 1과 6에서 서로 엉키게 된다. 때문에 여기서 탐색을 멈추고 1과 6에서 작은 수와 기준 데이터인 5와 변경한다.

1 4 2 0 3 / 5 / 6 9 7 8

이제 5보다 작은 데이터와 큰 데이터 각자 같은 방법을 반복하면 정렬이 완성됩니다.

퀵정렬의 평균 시간 복잡도는 $O(NlogN)$입니다. 앞의 두 정렬 알고리즘에 비해 굉장히 빠릅니다. 하지만 이미 데이터가 정렬되어있다면 시간복잡도는 $N(O^2)$이 된다는 단점이 있습니다.

# 계수 정렬

계수정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현될 수 있을 때만 사용할 수 있습니다. 예를 들어 시험성적의 경우에 0 ~ 100으로 제한되어 있고 정수형태이기 때문에 이러한 데이터에 적합하다고 설명할 수 있습니다. 계수정렬은 데이터 정수 범위만큼의 리스트를 만들어주고, 맨 앞부터 데이터를 세면서 데이터 값이 해당하는 리스트 위치의 값을 늘려주는 방법입니다. 
예시를 통해 설명해보도록 하겠습니다.

ex)
7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

데이터의 최대값은 9입니다. 때문에 0~9 범위의 리스트를 생성해줍니다.

0|1|2|3|4|5|6|7|8|9|
-|-|-|-|-|-|-|-|-|-|
0|0|0|0|0|0|0|0|0|0|

(7) 5 9 0 3 1 6 2 9 1 4 8 0 5 2

0|1|2|3|4|5|6|7|8|9|
-|-|-|-|-|-|-|-|-|-|
0|0|0|0|0|0|0|(1)|0|0|

7 (5) 9 0 3 1 6 2 9 1 4 8 0 5 2

0|1|2|3|4|5|6|7|8|9|
-|-|-|-|-|-|-|-|-|-|
0|0|0|0|0|(1)|0|1|0|0|

이를 반복하면 리스트가 완성되고, 등장한 가장 작은 수부터 차례로 출력하면 정렬이 완성됩니다.

계수정렬은 최악의 경우에도 $O(N+K)$를 보장합니다.(K는 데이터의 최대값) 하지만 K가 너무 클 경우와 최대값과 최소값의 차이가 클 경우에는 효율성이 떨어집니다. 이를 고려하여 방법을 선택하면 됩니다.

오늘 포스팅은 여기까지 하겠습니다.