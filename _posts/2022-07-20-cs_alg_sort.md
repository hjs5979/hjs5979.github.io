---
layout: single
title: 정렬 알고리즘
categories: 알고리즘
tag: [Algorithm]
use_math: true
toc: true
author_profile: true
sidebar:
  nav: docs
---

정렬 알고리즘에 대해서 정리해봤습니다.

# 선택 정렬

선택 정렬은 가장 원시적인 방법으로, 모든 데이터에서 가장 작은 데이터를 찾아 맨 앞의 데이터와 변경하고, 앞으로 간 데이터를 제외한 모든 데이터들 중에 다시 가장 작은 데이터를 찾아 앞에서 두번째 데이터와 변경하는 과정을 반복한다. 실제로는 배열을 순회하면서 데이터가 작은 값과 계속해서 순서를 바꾸는 방식으로 진행된다.

**ex)**

- 초기상태 7 5 9 0 3

- 1회전 : **5** **7** 9 0 3 ➡ **5** 7 **9** 0 3 ➡ **0** 7 9 **5** 3 ➡ **0** 7 9 5 **3**

1회전 설명 : 가장 작은 데이터를 찾는 과정 5와 7 교환 ➡ 5와 9 교환 x ➡ 0과 5 교환 ➡ 0과 3 교환 x

- 2회전 : 0 **7** **9** 5 3 ➡ 0 **5** 9 **7** 3 ➡ 0 **3** 9 7 **5**

2회전 설명 : 두번째로 작은 데이터를 찾는 과정입니다. 7과 9 교환 x ➡ 5와 7 교환 x ➡ 3과 5 교환

이 과정을 반복.

- 연산횟수 : $(N^2 + N) / 2 - 1$ = N + (N-1) + (N-2) + $\cdots$ + 2
- 시간복잡도 : $O(N^2)$

<br>

# 삽입 정렬

삽입 정렬은 맨 앞에 있는 데이터는 정렬되어 있다고 가정하고 그 다음 데이터부터 정렬한다. 비교 대상의 데이터가 작을 때, 해당 위치에 자신을 삽입한다.

ex)

- 초기상태 : 7 5 9 0 3

➡ 두번째 데이터인 5와 첫번째 데이터인 7을 비교했을 때, 5가 작기 때문에 7 위치에 5를 삽입

- 1회전 결과 : **5** 7 9 0 3

➡ 세번째 데이터인 9와 두번째 데이터 비교. 9가 더 크기 때문에 비교가 종료

- 2회전 결과 : 5 7 **9** 0 3

➡ 네번째 데이터인 0과 세번째 데이터를 비교. 0이 작기 때문에 비교가 계속 진행. 동일하게 두번째 데이터, 첫번째 데이터와 비교가 진행되고, 5의 위치에 0이 삽입.

- 3회전 결과: **0** 5 7 9 3

이 과정이 반복됩니다.

- 평균 시간복잡도 : $O(N^2)$
- 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작
- 최적 시간복잡도 : $O(N)$

<br>

# 버블 정렬

버블 정렬은 인접한 두 데이터를 비교하여 그 크기에 따라 위치를 서로 교환하는 정렬 방식

- 초기상태 : 7 5 9 0 3

- 1회전 : **5** **7** 9 0 3 ➡ 5 **7** **9** 0 3 ➡ 5 7 **0** **9** 3 ➡ 5 7 0 **3** **9**

1회전 설명 : 7과 5를 비교하여 위치 교환 ➡ 7과 9를 비교, 위치 교환 x ➡ 9과 0를 비교하여 위치 교환 ➡ 9와 3를 비교하여 위치 교환

- 2회전 : **5** **7** 0 3 9 ➡ 5 **0** **7** 3 9 ➡ 5 0 **3** **7** 9

2회전 설명 : 7과 5를 비교, 위치 교환 x ➡ 7과 0을 비교하여 위치 교환 ➡ 7과 3을 비교하여 위치 교환

이 과정을 반복.

평균, 최악의 시간복잡도 : $O(N^2)$

<br>

# 퀵 정렬

퀵 정렬은 특정 데이터를 기준으로 삼고 데이터를 기준 데이터보다 작은 데이터와 기준데이터보다 큰 데이터로 나눈 후, 작은 데이터와 큰 데이터 각자 정렬시키는 방식

6 3 9 0 2 7 1 8 4 (5) ➡ 5를 기준으로 데이터 분리
i               j

좌측탐색 : 3부터 시작하는 탐색단계에서는 5보다 큰 숫자를 찾고

우측탐색 : 4부터 시작하는 탐색단계에서는 5보다 작은 숫자를 찾는다.

좌측탐색에서는 6이 5보다 크기 때문에 선택. 우측탐색에서는 4가 5보다 작기 때문에 선택. -> 둘의 위치가 변경. -> 인덱스 i, j 이동

4 3 9 0 2 7 1 8 6 (5)
  i           j

i는 5보다 큰 수가 나올때까지 이동

4 3 9 0 2 7 1 8 6 (5)
    i         j

i가 큰 수를 찾았으니, j가 5보다 작은 수를 때까지 이동

4 3 9 0 2 7 1 8 6 (5)
    i       j

9와 1 교환 후 i, j 이동

4 3 1 0 2 7 9 8 6 (5)
      i   j

다시 i는 5부터 큰 수를 찾는데, j와 만나게 된다. 이곳에 5를 삽입한다.

4 3 1 0 2 (5) 7 9 8 6        

이제 5를 제외한 좌측과 우측 각각 같은 알고리즘으로 정렬을 하면 전체적으로 정렬이 된다.

- 평균 시간 복잡도는 $O(NlogN)$
- 이미 데이터가 정렬되어있다면 시간복잡도 증가
- 최악 시간복잡도 : $O(N^2)$

<br>

# 계수 정렬

계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현될 수 있을 때만 사용할 수 있다. 예를 들어 시험성적의 경우에 0 ~ 100으로 제한되어 있고 정수형태이기 때문에 이러한 데이터에 적합하다. 계수정렬은 데이터 정수 범위만큼의 리스트를 만들어주고, 맨 앞부터 데이터를 세면서 데이터 값이 해당하는 리스트 위치의 값을 늘려주는 방법이다.

ex)
7 5 9 0 3 1 6 2 9 1 4 8 0 5 2

데이터의 최대값은 9입니다. 때문에 0~9 범위의 리스트를 생성해줍니다.

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

(7) 5 9 0 3 1 6 2 9 1 4 8 0 5 2

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | (1) | 0   | 0   |

7 (5) 9 0 3 1 6 2 9 1 4 8 0 5 2

| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | (1) | 0   | 1   | 0   | 0   |

이를 반복하면 리스트가 완성되고, 등장한 가장 작은 수부터 차례로 출력하면 정렬이 완성됩니다.

- 평균, 최악 시간복잡도 : $O(N+K)$ (K는 데이터의 최대값) 
- K가 너무 클 경우와 최대값과 최소값의 차이가 클 경우에는 효율성이 떨어짐

<br>

# 쉘 정렬

쉘 정렬은 입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 삽입 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식입니다.

- 평균 시간 복잡도 : $O(N^1.5^)$
- 최악 시간 복잡도 : $O(N^2)$

<br>

# 힙 정렬

힙 정렬은 전이진 트리를 이용한 정렬 방식입니다. 구성된 전이진 트리를 힙 트리로 변환하여 정렬합니다.

평균, 최악 시간 복잡도 : $O(Nlog_2 5)$

<br>

# 2-Way 합병 정렬

2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬방식입니다.

평균, 최악 시간 복잡도 : $O(Nlog_2 N)$

<br>

# 기수 정렬

기수 정렬은 Queue를 이용하여 자릿수 별로 정렬하는 방식입니다. 같은 데이터는 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 데이터를 꺼내어 정렬하는 방식입니다.

평균, 최악 시간 복잡도 : $O(dN)$

# 정리

<table style="border: 2px;">
  <th>
    <td> 선택 정렬 </td>
    <td> 삽입 정렬 </td>
    <td> 버블 정렬 </td>
    <td> 퀵 정렬 </td>
    <td> 계수 정렬 </td>
    <td> 쉘 정렬 </td>
    <td> 힙 정렬 </td>
    <td> 2-Way 합병 정렬 </td>
    <td> 기수 정렬 </td>
  </th>
  <tr>
    <td> 평균 </td>
    <td> $O(N^2)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(NlogN)$ </td>
    <td> $O(N+K)$ </td>
    <td> $O(N^(1.5))$ </td>
    <td> $O(Nlog_2 5)$ </td>
    <td> $O(Nlog_2 N)$ </td>
    <td> $O(dN)$ </td>
  </tr>
  <tr>
    <td> 최악 </td>
    <td> $O(N^2)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(N+K)$ </td>
    <td> $O(N^2)$ </td>
    <td> $O(Nlog_2 5)$ </td>
    <td> $O(Nlog_2 N)$ </td>
    <td> $O(dN)$ </td>
  </tr>
</table>
