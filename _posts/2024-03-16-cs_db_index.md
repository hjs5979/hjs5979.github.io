---
layout: single
title: 인덱스
categories: DB
tag: [DB]
use_math: true
toc: true
author_profile: true
sidebar:
  nav: docs
---

# 인덱스란?

인덱스란 추가적인 저장공간을 사용하여 데이터베이스에서 데이터를 더 빠르게 검색활 수 있게 해주는 자료구조이다.

<br>

# 인덱스의 장점과 단점

- 장점
- 테이블 조회 성능을 향상시킨다.

- 단점
- 추가적인 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가적인 작업이 필요하다.
- 인덱스를 잘못 사용할 경우, 오히려 성능이 저하된다.

<br>

# 인덱스를 사용하면 좋은 경우

- 대규모 테이블
- 쓰기 작업이 자주 발생하지 않는 컬럼
- Where, Order by, Join이 자주 발생하는 컬럼
- 데이터의 중복도가 낮은 컬럼

<br>

# 인덱스 작동 방식

인덱스로 설정할 키를 선택한다. 키의 순서도 중요하다. 인덱스를 설정하면, 인덱스 컬럼으로 정렬한 데이터 구조가 생성된다.
이 데이터 구조의 예시로는 B-tree, B+tree, Bitmap를 들 수있다. 특정 데이터를 빠르게 가져오기 위한 구조라고 생각하면 된다.

<br>

# B+tree

B+tree는 이진트리의 한 종류다. 루트노드와 인터널 노드에는 키만 존재하고 리프노드에는 키와 값이 존재한다. 리프노드에 값이 있기 때문에, 리프노드에는 모든 노드가 있어야한다.
B+tree의 또다른 특징은 리프노드간의 이동이 가능하다는 점이다. 이러한 점 덕분에 범위탐색 시에 높은 효율을 보인다.
B+tree는 현재 DB에서 가장 많이 사용되는 데이터 구조이다.

인사정보라는 테이블이 있고, 사번이 3, 7, 8, 10, 13, 14, 17, 20, 23, 27인 레코드가 있다.
사번 컬럼을 인덱스로 설정했다고 가정해보자.

B+tree는 다음과 같이 생성된다.

![png](/assets/images/db/bptree.png)

다음과 같은 쿼리를 날린다고 가정하자.

```sql
SELECT *
  FROM 인사정보
 WHERE 1=1
   AND 사번 >= 20
;
```

3번의 이동을 통해 20 리프노드에 도달하고, 오른쪽으로 이동하여 >=20 범위의 모든 레코드에 대한 값을 찾을 수 있다.
FullScan 탐색을 한다면 8번의 이동이 필요할 것이다.(사번 순서대로 저장되었을 경우, 실제로는 INSERT,DELETE에 의해 위치가 섞일 수 있음)

실제 인덱스 구조를 간단하게 그려보았다.

![png](/assets/images/db/index.png)

20,23을 루트 노드라고 보았을 때, 각각은 리프노드의 주소값을 가지고 있을 것이다. 리프노드는 레코드의 페이지번호와 오프셋번호를 가지고 있어서, 레코드로 이동이 가능하다.
