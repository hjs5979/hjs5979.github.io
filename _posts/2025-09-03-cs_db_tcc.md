---
layout: single
title: 트랜잭션 동시성 제어(Transaction Concurrency Control)
categories: 데이터베이스
tag: [데이터베이스]
use_math: true
toc: true
author_profile: true
sidebar:
  nav: docs
---

# 1. 동시성 제어 방법

(1) Locking(로킹)

수정 작업 시, 레코드 또는 테이블을 잠금.(보통은 레코드 단위로 잠금)

- 비관적 방식(충돌할 가능성이 있다고 가정)
- Lock 대기시간 발생
- DeadLock 발생가능 (두 트랜잭션이 각자 하나의 테이블을 락을 걸고 있고, 다음 작업으로 서로의 테이블을 락을 걸려고 할때 DeadLock 발생) => 시간초과 시, DBMS에서 알아서 Rollback 시킨다고 함.(보통 0~1초 정도 대기)
- 쿼리 구현 방법 : select for update
- JPA 구현 방법 : @Lock

(2) TimeStamp 순서

트랜잭션에 타임스탬프를 붙여서, 데이터에 접근하는 시점마다 타임스탬프를 비교하여 순서대로 작동하게 함.

- 비관적 방식(충돌할 가능성이 있다고 가정, 트랜잭션 중간에 Rollback)
- 대기시간 없음
- DeadLock 없음
- Rollback 발생 확률 높음
- DBMS가 알아서 타임스탬프 비교
- 현대 DBMS에는 사용하지 않음

(3) 낙관적 검증

- 낙관적 방식(충돌할 가능성이 없다고 가정, 트랜잭션 마지막에 Rollback)
- 동시 처리 능력 증가
- 트랜잭션 대기시간 없음
- 장기 트랜잭션 철회 시 자원낭비
- 쿼리 및 애플리케이션으로 구현 방법 : 테이블 컬럼에 직접 Version 또는 Timestamp를 추가하여, update전에 Version 또는 Timestamp를 조회해 놓은 후, update의 where 조건에 조회한 Version 또는 Timestamp가 일치하는 경우에만 Update 하도록 구현
- JPA 구현 방법 : @Version

(4) 다중 버전 동시성 제어(MVCC)

입력 / 수정 : 커밋 전 내용을 UNDO 공간에 저장(타임스탬프 또는 트랜잭션ID와 함께 저장됨). 커밋한 내용은 DB에 적용
조회 : 트랜잭션 타임스탬프/ID를 비교하여 UNDO 공간에 있는 데이터 스냅샷들과 실제 DB의 데이터를 조합하여 데이터 조회(트랜잭션 시작 이전에 커밋된 데이터만 사용한다는 뜻)

동시 수정 : 그냥 수행됨. => 낙관적 검증 필요.

- 현대 DBMS에서 사용하는 방식

-->  다중 버전 동시성 제어 + 낙관적 검증 : MVCC는 항상 조회값에 대한 일관성을 보장해준다. DBMS는 동시 수정에 대해 DBMS로서 둘다 수행해야 하는 의무가 있다. 하지만 비즈니스 로직에서 동시 수정 시 갱신손실이 발생하기 때문에, 낙관적 검증을 통해 이를 보완한다.

# 2. @Transactional 

@Transactional은 트랜잭션의 동작 방식을 세밀하게 제어할 수 있는 다양한 속성을 제공합니다.

1. propagation (전파)

트랜잭션이 이미 진행 중인 다른 트랜잭션에 참여할지, 아니면 새로운 트랜잭션을 시작할지를 정의합니다.

REQUIRED (기본값): 이미 진행 중인 트랜잭션이 있으면 참여하고, 없으면 새로운 트랜잭션을 시작합니다.

REQUIRES_NEW: 항상 새로운 트랜잭션을 시작합니다. 기존 트랜잭션은 잠시 중단됩니다.

NESTED: 기존 트랜잭션 내부에 중첩 트랜잭션을 생성합니다. 부모 트랜잭션이 롤백되면 자식도 롤백되지만, 자식의 롤백은 부모에게 영향을 주지 않습니다.

2. isolation (격리 수준)

여러 트랜잭션이 동시에 실행될 때, 서로의 변경 사항을 얼마나 볼 수 있을지 격리 수준을 설정합니다. 격리 수준이 높을수록 데이터 일관성이 높아지지만, 동시성 성능은 떨어질 수 있습니다.

DEFAULT: 데이터베이스의 기본 격리 수준을 따릅니다.

READ_UNCOMMITTED: 커밋되지 않은 데이터(Dirty Read)를 읽을 수 있습니다. 가장 격리 수준이 낮습니다.

READ_COMMITTED: 커밋된 데이터만 읽을 수 있습니다. 대부분의 데이터베이스의 기본값입니다.

REPEATABLE_READ: 트랜잭션 내에서 한 번 읽은 데이터는 반복해서 읽어도 항상 동일합니다. (Non-repeatable read 방지)

SERIALIZABLE: 가장 높은 격리 수준으로, 동시성 문제를 완벽하게 해결하지만 성능 저하가 큽니다.

3. readOnly (읽기 전용)

readOnly = true로 설정하면 해당 트랜잭션은 데이터를 변경하지 않고 읽기만 할 것임을 선언합니다. 이는 데이터베이스 드라이버나 ORM(JPA)에게 읽기 전용 트랜잭션임을 알려주어 성능을 최적화할 수 있게 합니다.

4. rollbackFor / noRollbackFor (롤백 조건)

트랜잭션은 기본적으로 RuntimeException(비체크 예외) 이 발생하면 롤백을 수행하고, Exception(체크 예외) 이 발생하면 커밋을 수행합니다. 이 속성들을 사용하면 롤백 대상을 커스터마이징할 수 있습니다.

rollbackFor: 지정된 예외가 발생하면 롤백합니다.

noRollbackFor: 지정된 예외가 발생해도 롤백하지 않고 커밋합니다.


주의 : @Transactional을 사용할 때 가장 흔한 문제는 클래스 내부에서 다른 트랜잭션 메서드를 호출하는 경우, Required 메소드와 Requires_new 메소드가 한 클래스 안에 있는데, Required 메소드가 Requires_new 메소드를 호출하면 Requires_new 메소드는 새로운 트랜잭션이 아니라 기존 트랜잭션에 참여